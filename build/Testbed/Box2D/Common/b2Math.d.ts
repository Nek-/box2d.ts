export declare const b2_pi_over_180: number;
export declare const b2_180_over_pi: number;
export declare const b2_two_pi: number;
export declare function b2Abs(n: number): number;
export declare function b2Min(a: number, b: number): number;
export declare function b2Max(a: number, b: number): number;
export declare function b2Clamp(a: number, lo: number, hi: number): number;
export declare function b2Swap(a: any[], b: any[]): void;
export declare function b2IsValid(n: number): boolean;
export declare function b2Sq(n: number): number;
export declare function b2InvSqrt(n: number): number;
export declare function b2Sqrt(n: number): number;
export declare function b2Pow(x: number, y: number): number;
export declare function b2DegToRad(degrees: number): number;
export declare function b2RadToDeg(radians: number): number;
export declare function b2Cos(radians: number): number;
export declare function b2Sin(radians: number): number;
export declare function b2Acos(n: number): number;
export declare function b2Asin(n: number): number;
export declare function b2Atan2(y: number, x: number): number;
export declare function b2NextPowerOfTwo(x: number): number;
export declare function b2IsPowerOfTwo(x: number): boolean;
export declare function b2Random(): number;
export declare function b2RandomRange(lo: number, hi: number): number;
export declare class b2Vec2 {
    static ZERO: b2Vec2;
    static UNITX: b2Vec2;
    static UNITY: b2Vec2;
    static s_t0: b2Vec2;
    static s_t1: b2Vec2;
    static s_t2: b2Vec2;
    static s_t3: b2Vec2;
    x: number;
    y: number;
    constructor(x?: number, y?: number);
    Clone(): b2Vec2;
    SetZero(): b2Vec2;
    Set(x: number, y: number): b2Vec2;
    Copy(other: b2Vec2): b2Vec2;
    SelfAdd(v: b2Vec2): b2Vec2;
    SelfAddXY(x: number, y: number): b2Vec2;
    SelfSub(v: b2Vec2): b2Vec2;
    SelfSubXY(x: number, y: number): b2Vec2;
    SelfMul(s: number): b2Vec2;
    SelfMulAdd(s: number, v: b2Vec2): b2Vec2;
    SelfMulSub(s: number, v: b2Vec2): b2Vec2;
    Dot(v: b2Vec2): number;
    Cross(v: b2Vec2): number;
    Length(): number;
    LengthSquared(): number;
    Normalize(): number;
    SelfNormalize(): b2Vec2;
    SelfRotate(radians: number): b2Vec2;
    IsValid(): boolean;
    SelfCrossVS(s: number): b2Vec2;
    SelfCrossSV(s: number): b2Vec2;
    SelfMinV(v: b2Vec2): b2Vec2;
    SelfMaxV(v: b2Vec2): b2Vec2;
    SelfAbs(): b2Vec2;
    SelfNeg(): b2Vec2;
    SelfSkew(): b2Vec2;
    static MakeArray(length: number): b2Vec2[];
    static AbsV(v: b2Vec2, out: b2Vec2): b2Vec2;
    static MinV(a: b2Vec2, b: b2Vec2, out: b2Vec2): b2Vec2;
    static MaxV(a: b2Vec2, b: b2Vec2, out: b2Vec2): b2Vec2;
    static ClampV(v: b2Vec2, lo: b2Vec2, hi: b2Vec2, out: b2Vec2): b2Vec2;
    static RotateV(v: b2Vec2, radians: number, out: b2Vec2): b2Vec2;
    static DotVV(a: b2Vec2, b: b2Vec2): number;
    static CrossVV(a: b2Vec2, b: b2Vec2): number;
    static CrossVS(v: b2Vec2, s: number, out: b2Vec2): b2Vec2;
    static CrossVOne(v: b2Vec2, out: b2Vec2): b2Vec2;
    static CrossSV(s: number, v: b2Vec2, out: b2Vec2): b2Vec2;
    static CrossOneV(v: b2Vec2, out: b2Vec2): b2Vec2;
    static AddVV(a: b2Vec2, b: b2Vec2, out: b2Vec2): b2Vec2;
    static SubVV(a: b2Vec2, b: b2Vec2, out: b2Vec2): b2Vec2;
    static MulSV(s: number, v: b2Vec2, out: b2Vec2): b2Vec2;
    static MulVS(v: b2Vec2, s: number, out: b2Vec2): b2Vec2;
    static AddVMulSV(a: b2Vec2, s: number, b: b2Vec2, out: b2Vec2): b2Vec2;
    static SubVMulSV(a: b2Vec2, s: number, b: b2Vec2, out: b2Vec2): b2Vec2;
    static AddVCrossSV(a: b2Vec2, s: number, v: b2Vec2, out: b2Vec2): b2Vec2;
    static MidVV(a: b2Vec2, b: b2Vec2, out: b2Vec2): b2Vec2;
    static ExtVV(a: b2Vec2, b: b2Vec2, out: b2Vec2): b2Vec2;
    static IsEqualToV(a: b2Vec2, b: b2Vec2): boolean;
    static DistanceVV(a: b2Vec2, b: b2Vec2): number;
    static DistanceSquaredVV(a: b2Vec2, b: b2Vec2): number;
    static NegV(v: b2Vec2, out: b2Vec2): b2Vec2;
}
export declare const b2Vec2_zero: b2Vec2;
export declare class b2Vec3 {
    static ZERO: b2Vec3;
    static s_t0: b2Vec3;
    x: number;
    y: number;
    z: number;
    constructor(x?: number, y?: number, z?: number);
    Clone(): b2Vec3;
    SetZero(): b2Vec3;
    SetXYZ(x: number, y: number, z: number): b2Vec3;
    Copy(other: b2Vec3): b2Vec3;
    SelfNeg(): b2Vec3;
    SelfAdd(v: b2Vec3): b2Vec3;
    SelfAddXYZ(x: number, y: number, z: number): b2Vec3;
    SelfSub(v: b2Vec3): b2Vec3;
    SelfSubXYZ(x: number, y: number, z: number): b2Vec3;
    SelfMul(s: number): b2Vec3;
    static DotV3V3(a: b2Vec3, b: b2Vec3): number;
    static CrossV3V3(a: b2Vec3, b: b2Vec3, out: b2Vec3): b2Vec3;
}
export declare class b2Mat22 {
    static IDENTITY: b2Mat22;
    ex: b2Vec2;
    ey: b2Vec2;
    Clone(): b2Mat22;
    static FromVV(c1: b2Vec2, c2: b2Vec2): b2Mat22;
    static FromSSSS(r1c1: number, r1c2: number, r2c1: number, r2c2: number): b2Mat22;
    static FromAngle(radians: number): b2Mat22;
    SetSSSS(r1c1: number, r1c2: number, r2c1: number, r2c2: number): b2Mat22;
    SetVV(c1: b2Vec2, c2: b2Vec2): b2Mat22;
    SetAngle(radians: number): b2Mat22;
    Copy(other: b2Mat22): b2Mat22;
    SetIdentity(): b2Mat22;
    SetZero(): b2Mat22;
    GetAngle(): number;
    GetInverse(out: b2Mat22): b2Mat22;
    Solve(b_x: number, b_y: number, out: b2Vec2): b2Vec2;
    SelfAbs(): b2Mat22;
    SelfInv(): b2Mat22;
    SelfAddM(M: b2Mat22): b2Mat22;
    SelfSubM(M: b2Mat22): b2Mat22;
    static AbsM(M: b2Mat22, out: b2Mat22): b2Mat22;
    static MulMV(M: b2Mat22, v: b2Vec2, out: b2Vec2): b2Vec2;
    static MulTMV(M: b2Mat22, v: b2Vec2, out: b2Vec2): b2Vec2;
    static AddMM(A: b2Mat22, B: b2Mat22, out: b2Mat22): b2Mat22;
    static MulMM(A: b2Mat22, B: b2Mat22, out: b2Mat22): b2Mat22;
    static MulTMM(A: b2Mat22, B: b2Mat22, out: b2Mat22): b2Mat22;
}
export declare class b2Mat33 {
    static IDENTITY: b2Mat33;
    ex: b2Vec3;
    ey: b2Vec3;
    ez: b2Vec3;
    Clone(): b2Mat33;
    SetVVV(c1: b2Vec3, c2: b2Vec3, c3: b2Vec3): b2Mat33;
    Copy(other: b2Mat33): b2Mat33;
    SetIdentity(): b2Mat33;
    SetZero(): b2Mat33;
    SelfAddM(M: b2Mat33): b2Mat33;
    Solve33(b_x: number, b_y: number, b_z: number, out: b2Vec3): b2Vec3;
    Solve22(b_x: number, b_y: number, out: b2Vec2): b2Vec2;
    GetInverse22(M: b2Mat33): void;
    GetSymInverse33(M: b2Mat33): void;
    static MulM33V3(A: b2Mat33, v: b2Vec3, out: b2Vec3): b2Vec3;
    static MulM33XYZ(A: b2Mat33, x: number, y: number, z: number, out: b2Vec3): b2Vec3;
    static MulM33V2(A: b2Mat33, v: b2Vec2, out: b2Vec2): b2Vec2;
    static MulM33XY(A: b2Mat33, x: number, y: number, out: b2Vec2): b2Vec2;
}
export declare class b2Rot {
    static IDENTITY: b2Rot;
    s: number;
    c: number;
    constructor(angle?: number);
    Clone(): b2Rot;
    Copy(other: b2Rot): b2Rot;
    SetAngle(angle: number): b2Rot;
    SetIdentity(): b2Rot;
    GetAngle(): number;
    GetXAxis(out: b2Vec2): b2Vec2;
    GetYAxis(out: b2Vec2): b2Vec2;
    static MulRR(q: b2Rot, r: b2Rot, out: b2Rot): b2Rot;
    static MulTRR(q: b2Rot, r: b2Rot, out: b2Rot): b2Rot;
    static MulRV(q: b2Rot, v: b2Vec2, out: b2Vec2): b2Vec2;
    static MulTRV(q: b2Rot, v: b2Vec2, out: b2Vec2): b2Vec2;
}
export declare class b2Transform {
    static IDENTITY: b2Transform;
    p: b2Vec2;
    q: b2Rot;
    Clone(): b2Transform;
    Copy(other: b2Transform): b2Transform;
    SetIdentity(): b2Transform;
    SetPositionRotation(position: b2Vec2, q: b2Rot): b2Transform;
    SetPositionAngle(pos: b2Vec2, a: number): b2Transform;
    SetPosition(position: b2Vec2): b2Transform;
    SetPositionXY(x: number, y: number): b2Transform;
    SetRotation(rotation: b2Rot): b2Transform;
    SetRotationAngle(radians: number): b2Transform;
    GetPosition(): b2Vec2;
    GetRotation(): b2Rot;
    GetRotationAngle(): number;
    GetAngle(): number;
    static MulXV(T: b2Transform, v: b2Vec2, out: b2Vec2): b2Vec2;
    static MulTXV(T: b2Transform, v: b2Vec2, out: b2Vec2): b2Vec2;
    static MulXX(A: b2Transform, B: b2Transform, out: b2Transform): b2Transform;
    static MulTXX(A: b2Transform, B: b2Transform, out: b2Transform): b2Transform;
}
export declare class b2Sweep {
    localCenter: b2Vec2;
    c0: b2Vec2;
    c: b2Vec2;
    a0: number;
    a: number;
    alpha0: number;
    Clone(): b2Sweep;
    Copy(other: b2Sweep): b2Sweep;
    GetTransform(xf: b2Transform, beta: number): b2Transform;
    Advance(alpha: number): void;
    Normalize(): void;
}
